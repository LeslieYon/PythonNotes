#dict(字典)类型
#该类型可以创建一个key-value的对照表
#该类型属于增强的链表类型（使用key的哈希表查找对应的value），查删速度很快，但内存开销较大
a = {"a":1,"b":2,"c":3}
#可以通过下标的方式访问某个key对应的value
print(a["a"]) # 结果为 1
a["b"]=2.5 # a变为 {'a': 1, 'b': 2.5, 'c': 3}
#不能访问不存在的key
# print(a["d"]) # 错误：KeyError: 'd'
#可以使用如下表达式判断key是否存在
if "c" in a : #此表达式为真
	print("c存在于a")
#也可以使用dict类型自带的get函数
if a.get("d") : #此表达式为假，也可以写成 a.get("d") != None
	print("d存在于a")
if a.get("d",-1) == -1 : #此表达式为真
	print("d不存在于a")
#可以根据key删除对应的key和value
a.pop("c") #a变为 {'a': 1, 'b': 2.5} ，注意，如果key不存在，仍然会报错KeyError
#可以直接使用下标为dict增加元素
a["d"] = 4 #a变为 {'a': 1, 'b': 2.5, 'd': 4}
#注意：key不能为可变类型（例如dict、list等）
# a[a] = 5		#错误，dict类型是可变类型（unhashable type）
# a[[1,2,3]]	#错误，list类型是可变类型（unhashable type）
# a[(1,[1,2,3])] = "new" #错误，虽然tuple是不可变类型，但是tuple中包含了可变类型list
b = "b"
a[b] = 2.1 #正确，字符串类型不是可变类型，a变为 {'a': 1, 'b': 2.1, 'd': 4}
c = (1,2,3)
a[c] = "special" #正确，tuple类型不是可变类型，a变为 {'a': 1, 'b': 2.1, 'd': 4, (1, 2, 3): 'special'}

#set(集合)类型
#set类型相当于一种只存储key的dict（也具有dict的key不能修改特征，快速查删特征）
#set遵循数学中集合元素的唯一性、无序性
d = set([1,2,3,4,5,6,7,8,9]) #使用list来初始化set，d为 {1, 2, 3, 4, 5, 6, 7, 8, 9}
#使用add函数为set添加元素
d.add(10) #d变为 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
#集合中不能有重复的元素
d.add(1) #d依然为 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
#使用remove删除集合的元素
d.remove(10) #d变为 {1, 2, 3, 4, 5, 6, 7, 8, 9} ，注意：删除不存在的key会报错 KeyError
#集合可以进行交、并运算
e = set([4,6,8,10,12,14])
f = d & e #集合交运算，f结果为 {8, 4, 6}
f = d | e #集合并运算，f结果为 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14}

'''变量与不可变类型
虽然变量是一种可变类型，但是变量指向的类型（如字符串、tuple）仍然是一种不可变类型
在通过变量名称对不可变类型进行操作时，
涉及“修改”不可变对象的函数通常会返回另外一个修改过的对象，
这个返回的对象仍然是不可变类型'''
g = "A"
a[g.replace("A","a")] = 0.5 #通过字符串替换函数“修改”过的字符串仍然为不可变对象
print(a) #a变为 {'a': 0.5, 'b': 2.1, 'd': 4, (1, 2, 3): 'special'}
print(g) #g仍然为 A